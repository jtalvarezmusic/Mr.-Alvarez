<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Band Note & Rhythm Randomizer — Advanced</title>
  <!-- VexFlow v3 UMD -->
  <script src="https://unpkg.com/vexflow@3.0.9/releases/vexflow-min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; text-align: center; background: #f9f9f9; }
    h1 { margin-top: 20px; }
    .controls { display: flex; gap: 16px; justify-content: center; align-items: center; flex-wrap: wrap; margin-top: 12px; }
    .controls label { user-select: none; }
    .row { display: flex; gap: 40px; justify-content: center; flex-wrap: wrap; margin-top: 16px; }
    .label { font-weight: 600; margin: 6px 0 0; }
    .staff { width: 640px; background: #fff; border-radius: 12px; box-shadow: 0 2px 6px rgba(0,0,0,.2); padding: 10px; }
    .staff.wide { width: 920px; }
    button { margin: 16px 6px 24px; padding: 10px 20px; font-size: 18px; border: none; border-radius: 10px; background: #4caf50; color: #fff; cursor: pointer; }
    button:hover { background: #45a049; }
    .note-hint { font-size: 12px; color: #666; margin-top: -8px; }
    .hidden { display: none !important; }
  </style>
</head>
<body>
  <h1>Band Note & Rhythm Randomizer — Advanced</h1>

  <div class="controls">
    <label><input type="checkbox" id="bbTreble" /> Treble is Bb (Trumpet/Clarinet)</label>
    <label><input type="checkbox" id="allowFlams" checked /> Allow Flams (q, 8)</label>
    <label><input type="checkbox" id="allowOpenRolls" checked /> Allow Open Rolls (q, h)</label>
    <label><input type="checkbox" id="allowClosedRolls" checked /> Allow Closed Rolls (h, w)</label>
    <label><input type="checkbox" id="percOnly" /> Percussion only</label>
    <button id="shuffleBtn" onclick="drawRandom()">Shuffle (or press Space)</button>
  </div>

  <div class="row" id="windsRow">
    <div>
      <div class="label">Treble Clef</div>
      <div id="treble" class="staff"></div>
    </div>
    <div>
      <div class="label">Bass Clef</div>
      <div id="bass" class="staff"></div>
    </div>
  </div>

  <div class="row">
    <div>
      <div class="label">Percussion</div>
      <div id="perc" class="staff"></div>
      <div class="note-hint">Open = 3 slashes (q,h) · Closed = “Z” on stem (h,w) · Triplet 8ths are plain</div>
    </div>
  </div>

  <script>
    const VF = Vex.Flow;

    // Utilities
    function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
    function chance(p) { return Math.random() < p; }

    // Accidentals (naturals + C#, F#, G#, Bb, Eb, Db)
    const allowedAccidentals = {
      g: ["", "#"], a: [""], b: ["", "b"], c: ["", "#"], d: ["", "b"], e: ["", "b"], f: ["", "#"]
    };

    // MIDI helpers
    const NAT_MIDI = { c:0, d:2, e:4, f:5, g:7, a:9, b:11 };
    function midiFrom(letter, acc, oct) {
      let base = NAT_MIDI[letter];
      if (acc === "#") base += 1;
      if (acc === "b") base -= 1;
      return 12 * (oct + 1) + base;
    }
    function midiToKeyPreferClass(midi) {
      const pc = ((midi % 12) + 12) % 12;
      const oct = Math.floor(midi / 12) - 1;
      const pref = {
        0:{letter:"c",acc:""}, 1:{letter:"c",acc:"#"}, 2:{letter:"d",acc:""},
        3:{letter:"e",acc:"b"}, 4:{letter:"e",acc:""}, 5:{letter:"f",acc:""},
        6:{letter:"f",acc:"#"}, 7:{letter:"g",acc:""}, 8:{letter:"g",acc:"#"},
        9:{letter:"a",acc:""}, 10:{letter:"b",acc:"b"}, 11:{letter:"b",acc:""}
      };
      const { letter, acc } = pref[pc];
      return { letter, acc, oct };
    }
    function clampToBassRange(midi) {
      const A2 = 12*(2+1)+9;  // 45
      const C4 = 12*(4+1)+0;  // 60
      while (midi < A2) midi += 12;
      while (midi > C4) midi -= 12;
      return midi;
    }

    // Treble pool G3..G5 (written notes)
    const treblePool = [];
    for (let oct = 3; oct <= 5; oct++) {
      for (const letter of ["g","a","b","c","d","e","f"]) {
        for (const acc of allowedAccidentals[letter]) {
          const m = midiFrom(letter, acc, oct);
          if (m >= 55 && m <= 79) treblePool.push({ letter, acc, oct, midi: m });
        }
      }
    }

    // Percussion rhythms
    const rhythms = [
      { label: "Whole",   duration: "w",  count: 1 },
      { label: "Half",    duration: "h",  count: 2 },
      { label: "Quarter", duration: "q",  count: 4 },
      { label: "Eighth",  duration: "8",  count: 8 },
      { label: "16th",    duration: "16", count: 16 },
      { label: "Triplet 8ths", duration: "8", count: 12, triplet: true }
    ];

    // Probabilities (used only to choose a measure-wide roll type)
    const PROB_ANY_ROLL = 0.5;     // chance that a measure will have rolls at all
    const PROB_OPEN_VS_CLOSED = 0.5; // when both allowed

    // Drawing helpers
    function clearDiv(id) { const el = document.getElementById(id); if (el) el.innerHTML = ""; }
    function makeStave(divId, clef, width = 620, height = 160) {
      const div = document.getElementById(divId);
      const renderer = new VF.Renderer(div, VF.Renderer.Backends.SVG);
      renderer.resize(width, height);
      const context = renderer.getContext();
      const stave = new VF.Stave(10, 40, width - 20);
      stave.addClef(clef).setContext(context).draw();
      return { context, stave, width, height };
    }
    function addAccidentalIfNeeded(note, acc) {
      if (acc === "#" || acc === "b") note.addAccidental(0, new VF.Accidental(acc));
    }
    function drawSingleWholeKey(divId, clef, letter, acc, oct, width) {
      clearDiv(divId);
      const { context, stave } = makeStave(divId, clef, width);
      const key = `${letter}/${oct}`;
      const note = new VF.StaveNote({ clef, keys: [key], duration: "w" });
      addAccidentalIfNeeded(note, acc);
      const voice = new VF.Voice({ num_beats: 4, beat_value: 4 });
      voice.setStrict(false);
      voice.addTickables([note]);
      new VF.Formatter().joinVoices([voice]).format([voice], width - 60);
      voice.draw(context, stave);
    }

    // ---- Percussion helpers (open = 3 slashes, closed = Z on stem) ----
    function makePercNote(duration) {
      return new VF.StaveNote({ clef: "percussion", keys: ["b/4"], duration, stem_direction: 1 });
    }
    function addFlam(note) {
      const g = new VF.GraceNote({ keys: ["b/4"], duration: "8", slash: false, stem_direction: 1 });
      const gg = new VF.GraceNoteGroup([g], { slur: true });
      note.addModifier(0, gg);
    }
    function addOpenRoll(note) { note.addModifier(0, new VF.Tremolo(3)); } // 3 slashes
    function addClosedRoll(note) {
      const z = new VF.Annotation("z")
        .setFont("Arial", 18, "bold")
        .setJustification(VF.Annotation.Justify.LEFT)
        .setVerticalJustification(VF.Annotation.VerticalJustify.CENTER);
      note.addModifier(0, z);
      note._hasClosedRollZ = true;
    }
    function positionClosedRollZOnStem(notes) {
      notes.forEach(n => {
        if (!n._hasClosedRollZ) return;
        const stemX = (typeof n.getStemX === "function") ? n.getStemX() : n.getAbsoluteX();
        const noteX = n.getAbsoluteX();
        const deltaX = stemX - noteX;
        const mods = n.getModifiers ? n.getModifiers() : [];
        const zAnn = mods.find(m => m && m.text === "z");
        if (!zAnn) return;
        zAnn.setXShift(deltaX - 4); // center on stem
        zAnn.setYShift(-12);        // lift up so it sits on the stem, not the notehead
      });
    }

    // Measure-wide roll choice (only ONE type per measure)
    function pickMeasureRollType(allowOpen, allowClosed, rhythm) {
      const eligibleOpen   = allowOpen   && (rhythm.duration === "q" || rhythm.duration === "h");
      const eligibleClosed = allowClosed && (rhythm.duration === "h" || rhythm.duration === "w");

      if (!eligibleOpen && !eligibleClosed) return "none";
      if (Math.random() > PROB_ANY_ROLL) return "none";

      if (eligibleOpen && eligibleClosed) {
        return (Math.random() < PROB_OPEN_VS_CLOSED) ? "open" : "closed";
      }
      return eligibleOpen ? "open" : "closed";
    }

    function drawPercussion(rhythm, allowFlams, allowOpenRolls, allowClosedRolls, width) {
      clearDiv("perc");
      const { context, stave } = makeStave("perc", "percussion", width);

      let notes = [];
      let beams = [];
      let tuplets = [];

      // Decide the single roll type for the whole measure
      const rollType = pickMeasureRollType(allowOpenRolls, allowClosedRolls, rhythm);

      if (rhythm.duration === "w") {
        const n = makePercNote("w");
        if (rollType === "closed") addClosedRoll(n);
        else if (rollType === "open") addOpenRoll(n); // (will show 3 slashes if chosen)
        notes = [n];
      } else {
        for (let i = 0; i < rhythm.count; i++) {
          const n = makePercNote(rhythm.duration);

          // Flams allowed on q/8; flam skips roll on that note
          const canFlam = (rhythm.duration === "q" || rhythm.duration === "8");
          if (allowFlams && canFlam && chance(0.3)) {
            addFlam(n);
          } else {
            // Apply ONLY the chosen roll type (if this duration is eligible)
            if (rollType === "open" && (rhythm.duration === "q" || rhythm.duration === "h")) addOpenRoll(n);
            if (rollType === "closed" && (rhythm.duration === "h")) addClosedRoll(n);
          }

          notes.push(n);
        }

        if (rhythm.triplet) {
          for (let i = 0; i < notes.length; i += 3) {
            const group = notes.slice(i, i + 3);
            if (group.length === 3) tuplets.push(new VF.Tuplet(group, { num_notes: 3, notes_occupied: 2 }));
          }
        }
        if (rhythm.duration === "8" || rhythm.duration === "16") {
          beams = VF.Beam.generateBeams(notes);
        }
      }

      const voice = new VF.Voice({ num_beats: 4, beat_value: 4 });
      voice.setStrict(false);
      voice.addTickables(notes);

      new VF.Formatter().joinVoices([voice]).format([voice], width - 60);
      positionClosedRollZOnStem(notes);   // position “Z” on stem after formatting
      voice.draw(context, stave);

      beams.forEach(b => b.setContext(context).draw());
      tuplets.forEach(t => t.setContext(context).draw());
    }

    // Main
    function drawRandom() {
      const percOnly = document.getElementById("percOnly").checked;
      const bbTreble = document.getElementById("bbTreble").checked;

      const windsRow = document.getElementById("windsRow");
      windsRow.classList.toggle("hidden", percOnly);
      document.getElementById("perc").classList.toggle("wide", percOnly);

      const windWidth = 620;
      const percWidth = percOnly ? 920 : 660;

      // Pick treble note
      const choice = treblePool[randInt(0, treblePool.length - 1)];
      const { letter, acc, oct, midi: writtenMidi } = choice;

      // Concert MIDI
      let concertMidi = bbTreble ? (writtenMidi - 2) : writtenMidi;

      // Bass display as concert (A2..C4 clamp)
      const bassMidi = clampToBassRange(concertMidi);
      const bassKey = midiToKeyPreferClass(bassMidi);

      if (!percOnly) {
        if (bbTreble) {
          drawSingleWholeKey("treble", "treble", letter, acc, oct, windWidth);
        } else {
          const tKey = midiToKeyPreferClass(concertMidi);
          drawSingleWholeKey("treble", "treble", tKey.letter, tKey.acc, tKey.oct, windWidth);
        }
        drawSingleWholeKey("bass", "bass", bassKey.letter, bassKey.acc, bassKey.oct, windWidth);
      } else {
        clearDiv("treble"); clearDiv("bass");
      }

      const allowFlams = document.getElementById("allowFlams").checked;
      const allowOpenRolls = document.getElementById("allowOpenRolls").checked;
      const allowClosedRolls = document.getElementById("allowClosedRolls").checked;

      const rhythm = rhythms[randInt(0, rhythms.length - 1)];
      drawPercussion(rhythm, allowFlams, allowOpenRolls, allowClosedRolls, percWidth);
    }

    // Init + controls
    drawRandom();
    document.addEventListener("keydown", (ev) => { if (ev.code === "Space") { ev.preventDefault(); drawRandom(); } });
    document.getElementById("shuffleBtn").addEventListener("click", drawRandom);
    ["percOnly","allowFlams","allowOpenRolls","allowClosedRolls","bbTreble"].forEach(id => {
      document.getElementById(id).addEventListener("change", drawRandom);
    });
  </script>
</body>
</html>
